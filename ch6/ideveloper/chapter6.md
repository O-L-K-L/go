## 동시성

- 프로그램은 하나의 작업을 실행하기 위한 일련의 코드를 쭉 실행한 후 종료되도록 작성하는 경우가 많다.
- 그러나 여러작업을 동시적으로 실행하는것이 훨씬 도움이 되는 경우도있다.

  - 데이터를 조회하기 위한 여러개의 요청을 개별적인 소켓으로 동시에 전달받는 웹 서비스가 좋은 예 이다.

- Go에서 `동시성` 이란, 함수들을 다른 함수들과 독립적으로 실행할 수 있는 기능을 의미한다.
- 함수를 고루틴으로 생성하면 이 함수는 곧바로 실행되는 것이 아니라 실행해야 할 함수로 예약된 후 프로세스가 여력이 있을 때 실행되는 독립적인 작업 단위로 취급된다.

- Go에서의 `동시성 처리시 동기화`는 `CSP`(Communicating sequential Process, 통신 처리)리는 패러다임에서 비롯되었다.
  - CSP는 고루틴 사이에 데이터를 교환할 때 동시적 접속으로부터 데이터를 잠그는 기법이 아니라 메시지를 전달하는 모델이다.
  - 고루틴 사이의 동기화 및 메시지 교환을 위해 메시지 교환을 위한 핵심 데이터 타입은 `채널`이다.

#### 동시성과 병렬성

- `스레드`는 우리가 코드로 작성한 함수를 실행하기 위해 운영체제가 예약해 둔 실행 경로다.

  - 프로세스는 최소한 하나의 스레드를 가진다.
  - 각 프로세스를 위해 생성된 최초의 스레드를 주 스레드라고 부른다.

- 운영체제는 스레드를 물리적 프로세스를 통해 실행할 수 있도록 예약하며, Go 런타임 스케줄러는 고루틴을 논리적 프로세스를 통해 실행할 수 있도록 예약한다.

- `동시성`은 `병렬성`과는 다른 개념이다.

  - 병렬성은 여러개의 코드가 각기 다른 물리적 프로세서에서 동시에 실행되는 것을 말한다.
  - 동시성은 한번에 여러 작업을 관리하는 것을 말한다.

- 동시성이 성능이 더 좋은데, 그 이유는 운영체제와 하드웨어에 가해지는 부담이 적어 시스템이 더 많은 일을 할 수 있기 때문이다.
  - 이처럼 간결함을 통해 더 많은 것을 추구하는 것이 바로 개발 언어의 철학이다.

## 고루틴

- GOMAXPROCS
  - 스케줄러가 사용할 논리 프로세서의 개수를 스스로 조정할 수 있다.
- WaitGroup
  - 카운팅 세마포어를 이용해 실행 중인 고루틴의 기록을 관리하고 있다.
- defer
  - 현재 실행 중인 함수 내에서 함수가 리턴되기 전에 반드시 호출되어야 할 다른 함수를 예약하기 위한 것이다.
- runtime 패키지
  - Go 런타임 환경 변수를 조정하기 위한 기능들을 제공
- NumCPU
  - 사용 가능한 물리적 프로세서의 개수를 리턴한다.

`궁금한점`

- p166 "스케줄러에 의해 실행 순서가 변경" 부분 -> 순서가 변경되는 기준이 정해져있는게 있는지
- 논리 프로세서 vs 물리 프로세서의 명확한 차이

## 경쟁 상태

- 두개 혹은 그 이상의 고루틴이 동기화 없이 동시에 공유된 자원에 접근하여 읽기나 쓰기를 시도하게 되면 경쟁상태에 놓이게 된다.
- 경쟁 상태는 동시성 프로그래밍을 복잡하게 만드는 가장 큰 요인인 동시에 잠재적인 버그의 가장 큰 원인

- Go는 코드 내에서 경쟁 상태의 발생 가능성을 검사하는 특별한 도구를 제공한다.
  - 경쟁 상태가 쉽게 인지되지 않는 경우에는 더욱 유용하다.

```go
go build -race
// 경쟁 상태 검사 플래그와 함께 코드를 빌드
```

## 공유 자원 잠금

- go는 공유자원에 대한 접근을 잠금으로써 고루틴을 동기화 할 수 있는 기능들을 제공한다.
- 정수형 변수나 코드 블록에 순차적으로 접근하도록 해야 한다면 atomic 패키지와 sync 패키지의 함수들을 이용해야만 한다.

#### 원자성(atomic) 함수들

- 원자성 함수들은 정수 및 포인터에 대한 접근을 동기화 할 수 있는 저수준의 잠금 메커니즘을 제공한다.

- AddInt64
  - 값을 더할때
- LoadInt64
  - 값을 읽을때
- StoreInt64
  - 값을 쓸때

#### 뮤텍스

- 공유 자원에 대한 접근을 동기화 할 수 있는 또 다른 방법은 뮤텍스를 활용하는 것
- 상호 배타(mutual exclusion)의 개념에서 유래
- 코드 주변에서 임계 지역(critical section)을 생성해서 해당 코드를 한 번에 하나의 고루틴만이 실행 할수 있도록 보장

#### atomic 예제와 뮤텍스 예제 비교

`atomic`
https://play.golang.org/p/znEAtZf6BDk

`mutex`
https://play.golang.org/p/_h_1lvRgOF9

## 채널

- 원자성 함수들과 뮤텍스를 이용한 동기화는 공유자원에 대한 접근을 잠금으로써 고루틴을 동기화 할 수 있는 기능을 제공하기는 하지만 조금 부족함
  - 필요한 공유자원을 다른 고루틴에 보내거나 받아 고루틴 사이의 동기화를 지원하는 `channel`이라는 개념 존재
- 채널은 고루틴 사이를 연결하는 파이프처럼 동작하며, 둘 사이의 데이터 교환에 있어 동기화를 보장하는 메커니즘을 제공
- 채널을 선언할때 공유할 데이터의 타입을 명시해야 함
  - 내장타입, 사용자정의 타입, 구조체, 참조 타입의 값과 포인터는 모두 채널을 통해 공유 가능

`make 함수를 이용해 채널 생성`

```go
// 버퍼의 크기가 정해지지 않은 정수 채널
unbuffered := make(chan int)

// 버퍼의 크기가 정해진 문자열 채널
buffered := make(chan string, 10)
```

- 채널을 통해 값이나 포인터를 보내려면 "<-" 연산자 사용

`채널에 값 보내기`

```go

// 버퍼의 크기가 정해진 문자열 채널
buffered := make(chan string, 10)
// 채널을 통해 문자열을 보냄
buffered <- "gopher"
```

`채널로부터 값 전달받기`

```go

// 채널에서 문자열 가져오기
value := <- buffered
```

#### 버퍼가 없는 채널

- `버퍼가 없는 채널`은 값을 전달받기 전에 어떤 값을 얼마나 보유 할 수 있을지 그 크기가 결정되지 않은 채널을 말한다.
- 채널에 값을 보내거나 받기전에, 값을 전달하는 고루틴과 전달받는 고루틴이 같은 시점에 채널을 사용할 준비가 되어 있어야 한다.
  - 채널 사이에 값을 보내고 받는 작업은 본질적으로 동기화가 이루어지는 작업이기 때문에 서로 상대방이 없으면 필요한 작업을 수행하지 못하게 됨 (두 고루틴이 같은 시점에 준비되어 있지 않을 때)

![image](https://user-images.githubusercontent.com/26598542/73373140-99a25a80-42fb-11ea-8e05-e2a5a0076756.jpeg)

#### 버퍼가 있는 채널

- `버퍼가 있는 채널`은 고루틴이 값을 받아가기 전까지 채널에 보관할 수 있는 값의 개수를 지정할 수 있다.
- 보내고 받는 도작이 반드시 동시에 이루어지지 않아도 된다.
- 또한 값을 보내거나 받을때 잠금이 실행되는 방법에도 차이가 있다.
  - 값을 받는 작업의 잠금작업은 채널 내에 받아갈 값이 없을때만 실행
  - 값을 보내는 작업의 잠금은 채널 내에 버퍼가 가득 차서 더이상 값을 보관할수 없을때만 실행
- 버퍼가 없는 채널은 값을 보내고 받는 동작이 반드시 동시에 이루어진다는 것을 보장하지만 버퍼가 있는 채널은 이를 보장하지 않음

![image](https://user-images.githubusercontent.com/26598542/73373668-57c5e400-42fc-11ea-8086-3b33dd06dc96.jpeg)
