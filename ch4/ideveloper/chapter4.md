## 배열, 슬라이스, 맵 (chapter 4)

#### 배열과 슬라이스 선언의 차이점
- [] 연산자에 값을 지정하면 배열이 생성되고, 값을 지정하지 않으면 슬라이스가 생성된다.
```go
array := [3]int{10,20,30}
slice := []int{10,20,30}
```

#### nil 슬라이스 , 빈 슬라이스

`nil 슬라이스`
```go
var slice []int
```
- 초기화 코드를 선언하지 않으면 생성
- nil 슬라이스는 슬라이스를 return 하는 함수가 예외 상황이 발생하여 실제로 존재하지 않는 슬라이스를 리턴해야 할때 유용하게 사용
- 특징
  - 길이 0
  - 용량 0

`빈 슬라이스`
```go
slice := make([]int, 0)
slice := []int{}
```
- 초기화를 이용해 빈 슬라이스 생성
- 빈 슬라이스는 데이터베이스 질의가 결과 레코드 셋을 리턴하지 않는 등 빈 컬렉션을 표현해야 할때 유용

#### 슬라이스 길이,용량 계산
- 용량이 k인 내부 배열을 갖는 슬라이스에 대한 slice[i:j] 연산의 결과
  - 길이 : j-i
  - 용량 : k-i
- slice[i:j:k] 
  - 길이 : j-i
  - 용량 : k-i

#### 슬라이스 주의할점
- 어떤 슬라이스들이 내부 배열을 공유하는지 잊어버리기 쉽다.
- 따라서 용량을 설정할때 길이와 같은 값을 지정하면, append 작업이 처음으로 실행될 때 슬라이스와 내부 배열이 분리된다.
  - 이렇게 새로운 슬라이스를 원본 배열에서 분리하면 아무런 염려업시 필요한 값으로 변경 가능

#### range
- 값에 대한 참조를 리턴하는 것이 아니라 복사본을 생성

#### len과 cap
- go는 배열, 슬라이스, 채널에 대해 호출할 수 있는 len 과 cap이라는 내장 함수를 제공한다.
- len
  - 슬라이스의 길이 return
- cap
  - 용량을 return

#### 슬라이스를 함수에 전달하기
- 그냥 슬라이스를 값으로 전달하기만 하면 됨
- 슬라이스에 할당된 데이터는 내부 배열에 저장되어 있기 때문
- 포인터를 전달하기 위해 복잡한 문법을 사용할 필요가 없음
  - `4.1.5 함수에 배열 전달하기`와 비교 (배열은 포인터를 전달해야 했었음)
- 슬라이스는 24바이트 메모리를 사용
  - 포인터 필드 8바이트
  - 길이 8바이트
  - 용량 8 바이트

#### 맵의 내부구조
- 정렬되지 않은 컬렉션
  - 어떤 키/값 쌍이 리턴될 것인지 예측 불가
- 해시테이블 기반으로 구현되어 있음
  - 해시테이블 섫명 https://dev-kani.tistory.com/1

#### 맵 선언
- make 함수 or 맵 리터럴 사용 가능
```go
// make 함수 사용
dict := make(map[string]int)

// 맵 리터럴 사용
dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}
```
- 슬라이스, 함수, 슬라이스를 가진 구조체는 맵의 키로 사용 불가 (컴파일 에러)

#### 맵에서 데이터 조회하는 방법

1. 키의 값을 조회하는 동시에 키의 존재여부를 표현하는 플래그를 함께 확인

```go
value, exists := colors["Blue"]

if exists{
  fmt.Println(value)
}
```
2. 값만을 리턴받은 후 제로 값인지 검사해 키의 존재 여부를 판단하는 방법

```go
value:= colors["Blue"]

if value != ""{
 fmt.Println(value)
}
```

#### 맵에서 함수 전달
- 맵은 슬라이스와 마찬가지로 최소한의 자원만을 활용하도록 디자인 됨 (데이터 구조의 복사본 생성 x)